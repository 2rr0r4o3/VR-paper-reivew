# Another Way to Talk with Browser: Exploiting Chrome at Network Layer

## 1. 소개 (Introduction)
이 발표는 네트워크 계층에서 Chrome 브라우저를 악용하는 새로운 방법을 소개한다. 발표자는 360 Vulnerability Research Institute의 Rong Jian과 Guang Gong이다.

## 2. 브라우저 네트워킹 (Browser Networking)
- 자원 로딩에 중요한 역할을 한다.
- 고수준의 JavaScript API부터 각 소켓의 관리까지 포괄한다.
- 복잡하고 신뢰할 수 없는 입력을 정확하고 안전하게 파싱하고 처리하기 어렵다.

## 3. URLRequest: 간단한 예 (URLRequest: A Simple Example)
- Mojo 파이프를 통해 데이터를 수신한다.
1. URLLoader를 생성하고 URLRequest를 시작한다.
2. 캐시를 확인하고 HTTPStream을 요청한다.
3. 네트워크를 통해 요청을 보내고 응답을 읽는다.

```plaintext
Fetch()
Render Process       Network Service
    CreateLoaderAndStart
    OnReceiveResponse
    OnComplete
Check memory cache
    ⇐ IPC ⇒
```

## 4. 다양한 캐시 (Caches Everywhere)
여러 캐시는 컨텐츠를 획득, 저장, 유지하는 방식이 다르다.
서로 다른 요청이 서로 다른 캐시에서 리소스와 매치될 수 있다.
코드 캐시는 어떻게 되는가?

## 5. Chrome의 코드 캐싱 (Code Caching in Chrome)
WebAssembly 코드 캐싱
.wasm 리소스를 가져와 원격 서버에서 다운로드한다.
컴파일한다.

## 6. WebAssembly 코드 캐싱 (WebAssembly Code Caching)
.wasm 리소스를 다시 가져와 컴파일한다.
캐시 적중! 다운로드 및 컴파일이 필요 없다.

## 7. 코드 캐싱의 주요 질문 (Key Questions)
a. 언제 코드 캐시가 생성되는가?
b. 어떤 내용이 캐시되는가?
c. 어떻게 캐시 적중이 발생하는가?

## 8. 언제 캐시가 생성되는가 (When)
```c++
WasmStreamingClient::OnModuleCompiled
Platform::Current()->CacheMetadata(
    mojom::CodeCacheType::kWebAssembly, 
    KURL(response_url_), 
    response_time_,
    serialized_data.data(), serialized_data.size());
```
데이터를 CodeCacheHost에 전송한다 (브라우저 프로세스에서).
데이터는 <Key, Value> 쌍으로 맵에 저장된다 (렌더러 프로세스에서).\

## 9. 어떤 내용이 캐시되는가 (What)
```c++
bool NativeModuleSerializer::Write(Writer* writer) {
    DCHECK(!write_called_);
    write_called_ = true;
    WriteHeader(writer);
    for (WasmCode* code : code_table_) {
        if (!WriteCode(code, writer)) return false;
    }
    return true;
}
```
WasmModule의 모든 데이터가 직렬화되지는 않는다.

## 10. 어떻게 캐시 적중이 발생하는가 (How)
```c++
Resource* ResourceFetcher::CachedResource(const KURL& resource_url) const {
    if (resource_url.IsEmpty())
        return nullptr;
    KURL url = MemoryCache::RemoveFragmentIdentifierIfNeeded(resource_url);
    const WeakMember<Resource>& resource = cached_resources_map_.at(url);
    return resource.Get();
}
```
코드 캐시는 리소스 캐시와 연관되어 있다.
.wasm 리소스를 컴파일할 때 발생한다.
키로 맵 조회를 단순히 수행한다.

## 11. 코드 캐시 혼동 (Code Cache Confusion, CVE-2020-16015)
.wasm 리소스를 가져오지만 컴파일하지 않는다.
다시 가져와서 컴파일한다.
코드 캐시가 없다.
리소스 b의 캐시로 매핑된다.
리소스 a를 컴파일한다.
리소스 a가 리소스 b와 같은 URL을 가지고 있기 때문에 캐시 혼동이 발생한다.

## 12. 수정 (Fix, https://crrev.com/c/2534570)
코드 캐시 적중을 결정하는 시점을 변경했다.
이전: .wasm 리소스를 컴파일할 때 발생.
이후: 리소스 요청에 응답할 때 발생.
코드 캐시 저장 방식을 변경했다.
이전: 리소스 캐시에서 검색할 수 있었다.
이후: 캐시 적중 시 Response 객체에 저장된다.

## 13. 코드 캐시 요청 (Code Cache Request)
```c++
void ResourceLoader::CodeCacheRequest::MaybeSendCachedCode(
    mojo_base::BigBuffer data,
    ResourceLoader* resource_loader) {
    if (cached_code_response_time_.is_null() ||
        resource_response_time_.is_null() ||
        resource_response_time_ != cached_code_response_time_) {
        ClearCachedCodeIfPresent();
        return;
    }
    if (data.size() > 0) {
        resource_loader->SendCachedCodeToResource(std::move(data));
    }
}
```
코드 캐시가 처음 생성되었을 때 응답 시간을 기록한다.
응답 시간과 일치하는지 확인하여 코드 캐시 데이터가 해당 응답에 해당하는지 확인한다.

## 14. 동일한 응답 시간으로 다른 응답 (Different Responses with the Same Response Time)
응답 시간(고유 식별자로서의 역할).
Windows epoch(1601년 1월 1일) 이후 마이크로초.
Response 객체가 생성될 때 초기화된다.
JS API를 사용해 Response 객체를 생성할 수 있다.

```javascript
fetch(url)
fetch(url)
// 두 서비스 워커가 서로 다른 데이터를 가지고 Response를 지속적으로 생성
while(true) {
    new Response(body_a)
}
while(true) {
    new Response(body_b)
}
```

동일한 응답 시간을 가진 응답은 캐시를 공유하게 된다.
응답 본문이 다르더라도 동일한 캐시를 가진다.
응답을 컴파일하면 다시 캐시 혼동이 발생한다.

## 15. 글로벌 변수 (Global Variable in WASM)
```wasm
(global $first (mut i32))
(global $second (mut i32))
ArrayBuffer(sizeof(int) * 2)
global get/set 0
global get/set 1
global get/set 2
```
메타데이터에 선언된 글로벌 변수 실행 시 경계 검사 없음

## 16. 프리 리스트 헤드 (Freelist Head)
```plaintext
freelist_head next_
inverted_next_
...
next_
inverted_next_
...
null
0xffff...ff
...
Released Arraybuffer’s backing store in the free list (PartitionAlloc)
Classic free list corruption
- next_를 덮어써서 임의 할당 수행
```
## 17. Use-After-Free (UAF)
UAF로 힙 주소를 누출하고 ROP 체인을 생성하여 임의 코드를 실행한다.

## 18. QUIC Transport
QUIC 프로토콜은 UDP를 기반으로 하며 HTTPS 트래픽의 전송 성능을 향상시키기 위해 설계되었다.
Google 제품에서 전 세계적으로 배포됨.

```plaintext
NETWORK (IP)
TCP
TLS
HTTP/2
UDP
QUIC
QUICTransport HTTP/3
```
## 19. QUIC 프로토콜 (QUIC Protocol)
애플리케이션 수준의 웹 플랫폼 API.
QUIC 프로토콜을 사용해 원격 피어와 데이터를 교환할 수 있다.

```plaintext
new WebTransport("quic-transport://example.com:4433")
```

## 20. 연결 설정 (Establish the Connection)
```plaintext
Render process          Network Service
    Connect
    Remote Peer
    TLS Handshake (with its own framing format)
    Connection established
    Return quicHandshakeClient
    onConnectionEstablished
    Open unidirectional stream
    acceptUnidirectionalStream
    Return readable data pipe
    Send data
```

## 21. 스트림 열기 (Open Stream on the Connection)
```plaintext
Render process          Network Service
    Connect
    Remote Peer
    TLS Handshake (with its own framing format)
    Connection established
    Return quicHandshakeClient
    onConnectionEstablished
    Open unidirectional stream
    acceptUnidirectionalStream
    Return readable data pipe
    Send data
```
```c++
class QUIC_EXPORT_PRIVATE QuicTransportClientSession {
    quiche::QuicheCircularDeque<QuicTransportStream*> incoming_unidirectional_streams_;
};
```
세션에서 수신되었지만 렌더러에서 처리되지 않은 스트림을 포함한다.

## 22. Use-After-Free in Network Service (CVE-2021-38002)
```c++
void WebTransport::OnIncomingUnidirectionalStreamAvailable() {
    while (!unidirectional_stream_acceptances_.empty()) {
        quic::WebTransportStream* const stream = transport_->session()->AcceptIncomingUnidirectionalStream();
        streams_.insert(
            std::make_pair(stream->GetStreamId(), std::make_unique<Stream>(this, stream, std::move(writable_for_incoming))));
        std::move(acceptance).Run(stream->GetStreamId(), std::move(readable_for_incoming));
    }
}
```
AcceptUnidirectionalStream >>> OnIncomingUnidirectionalStreamAvailable
Use-After-Free 발생

## 23. 환경 (Environment)
Chrome 버전 94.0.4606.81, Windows 10
무제한 익스플로잇 시도 가능 (Network Service가 자동으로 재시작됨)

## 24. 결론 (Conclusions)
현대 브라우저는 많은 프로토콜을 지원하며, 해당하는 JavaScript API를 제공한다.
프로토콜 연결의 양쪽 끝을 어느 정도 제어할 수 있다.
높은 권한으로 신뢰할 수 없는 입력을 처리하는 네트워크 서비스는 보안 연구자들에게 좋은 타겟이 된다.
높은 수준의 네트워크 스택에서 논리적 결함은 메모리 안전성 버그를 유발할 수 있으며, 이는 악용하기 쉽다.









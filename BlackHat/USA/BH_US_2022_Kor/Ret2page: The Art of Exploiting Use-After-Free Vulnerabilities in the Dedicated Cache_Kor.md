# Ret2page: The Art of Exploiting Use-After-Free Vulnerabilities in the Dedicated Cache

# Ret2page: 전용 캐시의 Use-After-Free 취약점 활용 기술

## 소개
알리바바 보안 판도라 랩의 왕 용(Yong Wang)이 발표한 "Ret2page: 전용 캐시의 Use-After-Free 취약점 활용 기술"은 리눅스 커널의 특정 기술을 활용하여 Use-After-Free(UAF) 취약점을 공격하는 방법에 초점을 맞추고 있다. 발표에서는 리눅스 커널 힙에 대한 소개, 다양한 커널 익스플로잇, 그리고 CVE-2021-1048에 대한 상세한 사례 연구를 포함한다. 주요 개념인 Ret2page에 대해 설명하고 단계별로 이를 구현하는 방법을 다룬다.

## 리눅스 커널 힙 구조
리눅스 커널 힙은 Slab, Slub, SLOB 등 다양한 할당자 시스템을 통해 메모리를 관리한다. 이들 시스템은 메모리 할당과 해제를 효율적으로 관리하기 위해 설계되었으며, 각각의 특징과 구조가 있다.

### Slab 할당자
- **구조**: Slab은 오브젝트 캐시를 사용하여 빈번한 메모리 할당/해제를 최적화한다.
- **특징**: 커널 오브젝트의 캐시를 미리 할당하여 메모리 단편화를 줄인다.
- **장점**: 성능이 우수하고 메모리 단편화가 적다.
- **단점**: 메모리 사용량이 비교적 많다.

### Slub 할당자
- **구조**: Slub은 Slab의 개선된 버전으로, 더 단순한 구조와 성능 최적화를 제공한다.
- **특징**: 오브젝트의 메모리 레이아웃을 더 유연하게 관리한다.
- **장점**: Slab에 비해 메모리 사용량이 적고 관리가 용이하다.
- **단점**: 특정 상황에서 성능이 Slab보다 떨어질 수 있다.

### SLOB 할당자
- **구조**: SLOB은 작은 시스템에서의 메모리 절약을 위해 설계된 간단한 할당자이다.
- **특징**: 메모리 사용을 최소화하지만 성능은 떨어진다.
- **장점**: 메모리 사용량이 매우 적다.
- **단점**: 성능이 떨어지고 큰 시스템에서는 적합하지 않다.

## Use-After-Free(UAF) 취약점
UAF 취약점은 해제된 메모리를 계속해서 참조하는 버그로, 메모리 오염과 악성 코드 실행 등의 문제를 일으킬 수 있다. UAF 취약점을 활용한 공격은 주로 다음 단계를 따른다:
1. **취약한 포인터 해제**: 공격자는 특정 조건에서 포인터를 해제하여 메모리를 비운다.
2. **해제된 메모리 영역 재할당**: 동일한 메모리 영역을 재할당 받아 악성 데이터를 삽입한다.
3. **해제된 포인터를 통한 접근**: 해제된 포인터를 통해 악성 데이터를 실행한다.

## CVE-2021-1048 사례 연구
CVE-2021-1048은 리눅스 커널의 인쇄 스풀러 서브시스템에서 발견된 UAF 취약점이다. 이 취약점은 특정 조건에서 해제된 메모리 영역을 재사용할 수 있게 한다.

### 취약점 발생 과정
1. **인쇄 작업 해제**: 인쇄 작업이 끝난 후 메모리 영역이 해제된다.
2. **메모리 재할당**: 특정 시점에서 동일한 메모리 영역이 다시 할당된다.
3. **포인터 접근**: 해제된 포인터를 통해 해당 메모리 영역에 접근할 수 있게 된다.

### 취약점 세부 분석
이 취약점은 커널의 메모리 관리 방식에서 발생하며, 인쇄 작업이 완료된 후 특정 메모리 영역이 해제되고, 해제된 메모리 영역이 이후 다른 작업에서 다시 할당될 때 발생한다. 해제된 메모리 영역이 재사용되면서, 원래 해제된 포인터를 통해 접근할 수 있게 된다.

### 악용 과정
1. **인쇄 작업 트리거**: 취약한 인쇄 작업을 반복하여 메모리 해제를 유도한다.
2. **메모리 재할당 유도**: 동일한 메모리 영역이 다시 할당되도록 유도한다.
3. **악성 코드 삽입**: 재할당된 메모리 영역에 악성 코드를 삽입한다.
4. **코드 실행**: 해제된 포인터를 통해 악성 코드를 실행한다.

### 코드 예제
다음은 취약점을 설명하는 코드 예제이다:
```c
void free_print_job(struct print_job *job) {
    // 인쇄 작업 완료 후 메모리 해제
    kfree(job);
}

void process_next_job() {
    struct print_job *next_job;
    // 다음 인쇄 작업 할당
    next_job = kmalloc(sizeof(struct print_job), GFP_KERNEL);
    // 해제된 포인터를 통해 메모리 접근
    process_job(next_job);
}

## 취약점 악용 코드 예제
```c
void trigger_uaf() {
    struct print_job *job = kmalloc(sizeof(struct print_job), GFP_KERNEL);
    // 인쇄 작업 완료 후 메모리 해제
    kfree(job);
    // 동일한 메모리 영역에 악성 코드 삽입
    char *malicious_code = kmalloc(sizeof(struct print_job), GFP_KERNEL);
    memcpy(malicious_code, shellcode, sizeof(shellcode));
}

void execute_payload() {
    // 해제된 포인터를 통해 악성 코드 실행
    ((void (*)(void))malicious_code)();
}
```

## Ret2page 기술
Ret2page는 페이지 단위의 메모리 재활용을 통해 UAF 취약점을 악용하는 기술이다. 이 기술은 다음과 같은 단계를 포함한다:

1. **페이지 해제**: 취약점을 이용해 특정 페이지를 해제한다.
2. **페이지 재할당**: 해제된 페이지를 다시 할당받아 악성 코드를 삽입한다.
3. **코드 실행**: 재할당된 페이지를 통해 악성 코드를 실행한다.

### 상세 단계
1. **취약점 트리거링**: 취약한 커널 함수나 드라이버를 통해 메모리 페이지를 해제한다.
2. **메모리 재할당**: 커널에서 동일한 페이지를 재할당하도록 유도한다.
3. **페이로드 삽입**: 재할당된 페이지에 악성 페이로드를 삽입한다.
4. **악성 코드 실행**: 커널 코드 흐름을 조작하여 악성 페이로드를 실행한다.

### 코드 예제
다음은 Ret2page 기술을 설명하는 코드 예제이다:
```c
void trigger_uaf() {
    // 취약점을 유발하여 페이지를 해제
    if (vuln_condition) {
        kfree(vuln_page);
    }
}

void reallocate_page() {
    // 해제된 페이지를 다시 할당
    new_page = kmalloc(PAGE_SIZE, GFP_KERNEL);
    memcpy(new_page, malicious_code, sizeof(malicious_code));
}

void execute_code() {
    // 재할당된 페이지를 통해 악성 코드 실행
    ((void (*)(void))new_page)();
}
```

## 취약점 방어
UAF 취약점을 방어하기 위해 다음과 같은 방법을 사용할 수 있다:

메모리 안전성 검증: 커널 메모리 할당 및 해제 과정에서 안전성을 철저히 검증한다.
타입 격리: 서로 다른 타입의 오브젝트가 동일한 메모리 페이지를 공유하지 않도록 격리한다.
정적 분석 도구 사용: 코드 베이스에 대해 정적 분석 도구를 사용하여 잠재적인 UAF 취약점을 식별한다.
런타임 보호 기법: 커널의 런타임 동안 메모리 접근을 모니터링하고 이상 징후를 탐지한다.

## 결론
Ret2page 기술은 UAF 취약점을 악용하여 커널에서 임의 코드를 실행할 수 있는 강력한 공격 방법이다. 이 기술은 메모리 관리와 페이지 재활용에 대한 깊은 이해를 필요로 하며, 이를 통해 다양한 보안 방어를 우회할 수 있다. 

### Cautious! A New Exploitation Method! No Pipe but as Nasty as Dirty Pipe

#### 1. 소개 (Introduction)

본 발표는 DirtyCred라는 새로운 익스플로잇 방법에 대해 탐구한다. 이 방법은 파이프를 사용하지 않으면서도 Dirty Pipe와 마찬가지로 치명적인 효과를 낸다. 
발표자들은 Northwestern University의 Zhenpeng Lin, Yuhang Wu, Xinyu Xing이다.

#### 2. Dirty Pipe 요약 (Recap About Dirty Pipe)

- **CVE-2022-0847**: 리눅스 커널의 파이프 서브시스템에 존재하는 초기화 누락으로 인해 발생하는 취약점.
- **영향받는 버전**: 커널 v5.8 이상.
- **특징**:
  - 데이터 전용 익스플로잇.
  - 효과적인 완화 방법이 없음.
  - 읽기 권한이 있는 파일을 덮어쓸 수 있음.
  - 안드로이드에서 LPE(Local Privilege Escalation) 시연.

#### 3. Dirty Pipe에서 배운 점 (What We Learned)

- 데이터 전용 익스플로잇의 강력함.
- 범용 익스플로잇으로의 가능성.
- CFI(Control Flow Integrity) 우회 (안드로이드 커널에서 활성화).
- 새로운 완화 방법의 필요성.

#### 4. DirtyCred 소개 (Introducing DirtyCred)

- **아이디어**: 리눅스 커널의 Credentials를 스와핑.
- **장점**:
  - 범용적인 익스플로잇 방법, 단순하면서도 효과적.
  - 데이터 전용 범용 익스플로잇 작성 가능.
  - 컨테이너에서 적극적으로 탈출 가능.

#### 5. Dirty Pipe와의 비교 (Comparison with Dirty Pipe)

| 특성 | Dirty Pipe | DirtyCred |
| ---- | ---------- | --------- |
| 범용적인 익스플로잇 방법? | 예 | 예 |
| 데이터 전용 범용 익스플로잇 작성 가능? | 예 | 예 |
| CFI가 활성화된 안드로이드에서 공격 가능? | 예 | 예 |
| 컨테이너에서 적극적으로 탈출 가능? | 아니오 | 예 |
| 여전히 위협이 존재? | 예 | 예 |

#### 6. 커널 크리덴셜 (Kernel Credential)

- **설명**: 커널에서 권한 정보를 포함하는 속성.
- **주요 유형**:
  - Task credentials: 작업 크리덴셜.
  - Open file credentials: 열린 파일 크리덴셜.
- **구조**: `struct cred`로 커널 힙에 저장.

```c
struct cred {
    atomic_t usage;
    kuid_t uid;    // 사용자 ID
    kuid_t gid;    // 그룹 ID
    kuid_t suid;   // 저장된 사용자 ID
    kuid_t sgid;   // 저장된 그룹 ID
    // ...
};

#### 7. Task Credentials 공격 (Attacking Task Credentials)

- **단계 1**: 취약점을 이용해 비권한 크리덴셜 해제.
- **단계 2**: 해제된 메모리 슬롯에 권한 있는 크리덴셜 할당.
- **단계 3**: 권한 있는 사용자로 작동.

#### 8. Open File Credentials 공격 (Attacking Open File Credentials)

- **설명**: 파일 객체에 대한 권한 확인을 우회.
- **단계 1**: 파일 객체를 해제한 후 쓰기 전 권한 확인.
- **단계 2**: 해제된 메모리 슬롯에 읽기 전용 파일 객체 할당.
- **단계 3**: 권한 있는 사용자로 작동하여 파일에 쓰기.

#### 9. 크리덴셜 해제 도전 과제 (Challenge 1: Free Credentials)

- **설명**: 대부분의 취약점은 일반 캐시에서 발생.
- **해결 방법**: Pivoting Vulnerability Capability를 사용해 잘못된 쓰기 또는 해제를 피벗.

```c
void pivot_vuln() {
    // 예시: 특정 조건에서 자유롭게 메모리 해제
    if (vuln_condition) {
        kfree(vuln_obj);
    }
}

#### 10. 권한 있는 Task Credentials 할당 도전 과제 (Challenge 2: Allocating Privileged Task Credentials)

**설명**: 비권한 사용자는 비권한 크리덴셜과 함께 제공.
**해결 방법**:
- 권한 있는 사용자 공간 프로세스 트리거 (예: root SUID 실행 파일).
- 권한 있는 커널 스레드 트리거 (예: 커널 Workqueue).

```c
void trigger_root_suid() {
    system("/path/to/root_suid_binary");
}

void trigger_kernel_thread() {
    schedule_work(&privileged_work);
}

#### 11. 파일 익스플로잇 안정화 도전 과제 (Challenge 3: Stabilizing File Exploitation)

**설명**: 파일 객체 스와핑은 권한 확인 후 실제 파일 쓰기 사이에 발생해야 함.
**해결 방법**:
- Userfaultfd 또는 FUSE를 사용해 커널 실행 일시 중지.
- 파일 잠금을 사용해 커널 실행 일시 중지.

```c
void stabilize_exploit() {
    // FUSE를 사용해 파일 접근 중지
    fuse_fd = open("/path/to/fuse", O_RDWR);
    ioctl(fuse_fd, FUSE_IOC_PAUSE);
}

#### 12. 데모 (Demo Time)

- **CVE-2021-4154**: Centos 8과 Ubuntu 20에서 시연.
- 안드로이드 커널에서 CFI가 활성화된 상태에서 시연.

#### 13. DirtyCred의 장점 (Advantages of DirtyCred)

- 범용적인 방법.
- 컨테이너와 안드로이드에 적용 가능.
- 단순하지만 강력함.
- KASLR, CFI를 다룰 필요 없음.
- 데이터 전용 방법.

#### 14. DirtyCred에 대한 방어 (Defense Against DirtyCred)

**근본적인 문제**: 객체 격리가 유형이 아닌 권한 기반.
**해결 방법**: 권한 있는 크리덴셜을 비권한 크리덴셜과 격리.
- 가상 메모리를 사용해 격리 (Cross cache 공격 불가).

```c
void isolate_credentials() {
    // 가상 메모리 격리 구현
    mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
}

#### 15. 결론 (Takeaways)

- 새로운 익스플로잇 개념: DirtyCred.
- 다양한 도전 과제에 대한 원칙적인 접근.
- 다양한 커널에 대한 범용 익스플로잇.
- 효과적인 방어 방법.




# Is WebAssembly Really Safe? - Wasm VM Escape and RCE Vulnerabilities

1. 소개
WebAssembly(Wasm)는 W3C 커뮤니티 그룹에서 개발한 기술로, 원래는 개발자들이 네이티브 C/C++ 코드를 브라우저에서 실행할 수 있도록 하기 위해 만들어졌다. Wasm은 가상 머신에서 코드가 실행되므로 Java처럼 크로스 플랫폼이 가능하다. 현재 Wasm은 임베디드 시스템, 클라우드 컴퓨팅 등 다양한 분야에서 사용되고 있다. 이는 WebAssembly 보안 연구가 중요한 이유이다.

Wasm은 제어 흐름 스택과 데이터 스택을 분리하여 코드를 안전하게 실행한다. 실행 중에는 데이터 스택만 수정할 수 있고, 제어 흐름 스택은 파싱 단계에서 고정된다. 따라서 버퍼 오버플로우 취약점이 있는 C/C++ 프로그램이 Wasm 바이트코드로 컴파일되면 이는 악용될 수 없다. 모든 취약점 오버플로우는 데이터 스택에서 발생하며 프로그램 흐름 스택에는 영향을 미치지 않는다. WebAssembly 시스템 인터페이스(WASI)는 파일 조작, 네트워크 등 시스템 API를 사용하기 위한 인터페이스로, 권한에 의해 제한되므로 안전하다.

이전 연구들은 주로 컴파일러와 링커 수준의 Wasm 보안 취약점에 초점을 맞췄지만, Wasm 가상 머신 탈출에 대한 연구는 거의 없다. 본 논문은 Wasm 가상 머신의 취약점에 집중하고 있으며, 이를 찾기 위해 퍼징 도구를 설계하였다. 

왜 기존 퍼징 도구 대신 새로운 퍼징 프레임워크를 설계했는가? 
Wasm 파일은 특정 데이터 구조를 가지고 있으며, Wasm 런타임이 이를 검증할 때 검증을 통과한 샘플만 실행될 수 있다. AFL 등의 기존 도구가 생성한 샘플은 원시 이진 파일로, 데이터 구조 간의 상관 관계가 없어 효과적이지 않다. 본 논문은 Wasm 가상 머신의 구조를 분석하여 Wasm 가상 머신의 세 가지 잠재적 취약점을 발견했다: Wasm 파일의 파서, 바이트코드의 해석 및 실행, WASI API. 본 논문의 퍼징 도구는 이러한 상황을 기반으로 설계되었다.

본 논문은 Wasm 가상 머신에서 몇 가지 악용 가능한 취약점을 발견하였다. Wasm 가상 머신의 아키텍처를 소개하고, WASI API에 존재하는 취약점을 보여주며, 바이트코드를 사용하여 힙을 스프레이하고, 바이트코드의 off-by-one 취약점을 통해 코드 실행을 얻는 방법을 설명할 것이다.

2. WASM

2.1 WASM 구조
Wasm은 여러 섹션으로 구성되어 있으며, 코드 섹션은 Wasm 바이트코드를 저장하고, 임포트 섹션은 일부 임포트의 이름 문자열을 저장하며, WASI도 임포트 섹션에서 임포트된다.

2.2 WASM S-Expression
S-Expression은 인간이 이해할 수 있는 형식으로, Wasm 바이너리와 동일하게 여러 섹션으로 구성된다. Wasm 바이트코드는 스택 기반으로, 예를 들어 i32.const 16191은 스택에 값 16191을 푸시하고, i32.add는 스택에서 두 값을 팝하여 더한 다음 결과를 스택에 푸시한다.

2.3 WASM 가상 머신
```
(module
  (memory $0 1)
  (export "memory" (memory $0))
  (export "main" (func $main))
  (func $main (; 1 ;) (result i32)
    (i32.const 16191)
  )
)
```

3. WASM-Fuzzer
본 논문은 Wasm 파일 구조, WASI API, 런타임의 바이트코드 구현에 집중한다. Wasm 샘플 생성기를 개발하였다. 이는 섹션별로 샘플을 구성하며, 각 섹션을 클래스 구조로 추상화하고 이를 유지 관리한다. 생성기의 설계는 객체 지향적인 접근을 채택하고 있으며, 전체 WASM의 데이터 구조를 분할한다.

Wasm은 다양한 섹션으로 구성되므로, 각각의 섹션을 처리하기 위한 다양한 클래스를 설계하고, 각 객체는 자신의 작은 부분 샘플 생성을 담당한다. 코드 섹션의 경우 주로 Wasm 바이트코드를 저장하며, 각 바이트코드는 대응하는 클래스를 가지고, 이는 랜덤 데이터에서 데이터를 가져와 필요한 피연산자를 생성한다. 이 클래스는 피연산자의 범위를 제한하는 몇 가지 규칙도 추가한다.

일부 바이트코드의 피연산자는 Wasm의 다른 객체에 의존할 수 있으며, 이러한 객체를 위해 컨텍스트 관련 데이터를 저장하기 위해 Context 클래스를 설계하고, 최종적으로 해당 바이트코드에 대한 이진 데이터를 샘플로 출력한다.

샘플 생성기의 품질은 퍼징 효과에 직접적으로 영향을 미친다. 데이터 구조에서 일부는 상수인 경우가 있어, 변이(mutation)를 통해 새로운 경로를 탐지할 필요가 없다. 예를 들어, WASI의 API 이름은 고정된 문자열이며, 이러한 문자열의 변이는 효과가 없으므로 고정한다. 또 다른 예로, 필드가 CRC 체크 값인 경우, 랜덤 변이로는 올바르게 생성될 수 없으므로, 데이터에 따라 CRC를 계산하여 해당 필드를 채워야 한다. 일부 필드의 값은 범위가 제한되어 있어, 예를 들어 문자열 변수의 값이 ["apple", "banana"] 목록의 하나로 제한되는 경우, 필드 생성 시 목록에서 선택하면 된다.

샘플 생성기에서 자체 전략적 랜덤 넘버 생성기를 구현하였다.

```
import random

class RandomGenerator:
    def __init__(self, seed=None):
        self.seed = seed
        self.random = random.Random(seed)

    def randint(self, a, b):
        # 경계 값을 더 많이 나타나게 하는 전략적 구현
        boundaries = [a, b, a + 1, b - 1]
        if self.random.random() < 0.5:
            return self.random.choice(boundaries)
        return self.random.randint(a, b)
```

이 샘플 생성기가 독립적으로 실행될 때, 범위 값은 /dev/urandom에서 가져온다. 그러나 이를 AFL, libfuzzer 등 도구에 추가하고 커버리지 안내를 지원하려면, 범위의 데이터 소스를 원래 AFL, libfuzzer 등 도구에서 생성한 이진 데이터로 변경하면 된다. 즉, 모든 값은 더 이상 자율적으로 랜덤이 아니며, 퍼징 도구의 샘플을 기반으로 한 데이터 매핑을 설정하는 것과 같다. 퍼징 도구의 원본 데이터의 각 데이터는 샘플 생성기 내 상태에 고유하게 대응하며, 샘플 생성기가 커버리지를 기반으로 안내할 수 있게 한다.

데이터의 값이 충분하지 않으면 /dev/urandom에서 무작위로 읽는 대신 상수 0을 반환하여 매핑의 고유성을 보장한다. 데이터의 값이 충분하지 않으면 무작위로 숫자를 반환하며, 동일한 데이터는 샘플 생성기에 고유한 상태를 가져오지 않으므로 커버리지 안내를 완료할 수 없다.

4. WASM-Runtime

4.1 WASM3
Wasm3는 _pc 스택과 _sp 스택을 사용하며, _pc 스택은 런타임 함수와 명령어에 대응하는 파라미터를 저장한다. _pc 스택의 파라미터는 _sp 스택의 하위스크립트에서 파라미터를 나타내는 슬롯 인덱스를 사용하며, 런타임 함수에서 _sp 스택의 파라미터 값을 읽는다.

```
void wasm_runtime_function() {
    int _sp[1024]; // 데이터 스택
    int _pc[256];  // 실행 스택
    // 실행 흐름
    _pc[0] = LOAD_OPCODE;
    _sp[0] = OPERAND;
    ...
}
```

데이터 조작은 _sp 스택에서 이루어지며, _sp 스택은 데이터만 저장하므로, 전통적인 의미의 스택 오버플로우(예: memcpy(buf, P, 0x10000))는 Wasm 바이트코드의 프로그램 흐름에 영향을 미치지 않는다. 따라서 Wasm의 설계는 안전하지만, Wasm 런타임 자체에 문제가 있는 경우 안전하지 않다. 예를 들어, 런타임 컴파일 과정에서 핸들이 3개의 슬롯을 필요로 하지만, 컴파일러가 슬롯 수를 2개로 잘못 계산하면, 세 번째 슬롯 값은 다음 핸들의 주소가 되며, 이 값이 _sp 스택에 접근하는 하위스크립트로 사용된다. 이는 본 논문이 발견한 바이트코드 수준의 취약점이다.

Wasm 런타임은 가상 머신이므로, 가상 머신 탈출의 아이디어를 참조할 수 있다. 가상 머신은 종종 다양한 장치의 취약점을 통해 탈출한다. 많은 Wasm 런타임에서 WASI API가 구현되어 있다. 이러한 API는 호스트에서 동작하므로, 이러한 API의 취약점을 찾을 수 있다.

4.2 WasmEdge

WasmEdge의 구조 설계는 데이터 스택과 실행 스택의 분리도 포함된다. 실행 스택에는 일련의 명령어 객체가 존재한다. 본 논문은 WasmEdge에서 PC 스택의 off-by-one 취약점을 발견하여 원격 코드 실행(RCE)을 성공적으로 수행하였다. 이 과정은 매우 정교하며, 시연에서 자세히 설명할 것이다.

```
fn main() {
    let mut pc_stack = vec![0; 256]; // 실행 스택
    let mut sp_stack = vec![0; 1024]; // 데이터 스택
    // 명령어 실행 흐름
    pc_stack[0] = load_opcode();
    sp_stack[0] = operand();
    ...
}
```

5. 결론
Wasm 표준은 안전하게 설계되었지만, Wasm 런타임은 완전히 안전하지 않다. Wasm VM의 탈출 트리거는 주로 바이트코드 인터프리터와 WASI API를 기반으로 하므로, 설계 시 이 두 모듈에 집중해야 한다. 본 논문은 이 두 측면에서 버그를 검사하기 위해 더 많은 테스트를 추가할 것을 제안한다. 특히, 명령어의 피연산자와 WASI API에 전달되는 매개변수를 엄격히 검사해야 한다. 본 논문은 앞으로 더 많은 Wasm 런타임 프로젝트를 연구하여 관련 프로젝트 보안에 더 많은 지원을 제공할 것이다.


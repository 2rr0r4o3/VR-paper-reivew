# The Hat Trick: Exploit Chrome Twice from Runtime to JIT

1. 소개 (Introduction)
이 논문은 V8 JavaScript 엔진의 두 가지 중요한 취약점을 이용하여 원격 코드 실행(RCE)을 수행하는 방법을 다룬다. V8 엔진은 Google Chrome, Node.js 등 현대 웹 브라우저와 응용 프로그램에서 핵심적인 역할을 하며, 광범위하게 사용된다. 이러한 널리 사용되는 특성 때문에 해커의 주요 타겟이 된다. 논문에서는 CVE-2022-4174와 Chromium-Issue-1423610이라는 두 가지 취약점을 탐구하며, 각각의 취약점이 어떻게 발생하고 어떻게 악용될 수 있는지 설명한다.

2. Promise.any() 함수에서 TheHole 값 유출 (TheHole Value Leakage in Promise.any() Function)

2.1 개요 (Overview)

Promise.any()는 ES2021에 추가된 새로운 기능으로, 여러 개의 Promise 객체를 받아 가장 먼저 해결된(fulfilled) Promise의 값을 반환한다. 만약 모든 Promise가 거부(rejected)되면 AggregateError를 반환한다. 이 함수는 비동기 작업을 효율적으로 처리할 수 있게 해주지만, 내부적으로 복잡한 로직을 가지고 있어 취약점이 발생할 수 있다.

2.2 RCE 취약점의 근본 원인 (The Root Cause of RCE Vulnerability)

CVE-2022-4174는 Promise.any() 함수의 remainingElementsCount 변수 처리에서 발생하는 취약점으로, 잘못 초기화된 errors 배열 요소가 TheHole 값을 포함하게 된다. TheHole 값은 V8 엔진 내부에서 초기화되지 않은 JS 객체를 나타내는 값이다.

Promise.any() 함수의 PerformPromiseAny 함수는 입력 배열을 반복하면서 Promise 객체의 then() 함수를 호출하는데, 이 과정에서 잘못된 remainingElementsCount 값이 사용되어 errors 배열에 TheHole 값이 유출된다. 예를 들어, remainingElementsCount 변수가 1로 초기화되며, 이는 올바르게 초기화되지 않은 상태에서 errors 배열의 크기를 잘못 계산하게 된다.

```
const promise1 = new Promise((resolve, reject) => { 
  if (Math.random() > 0.5) 
    resolve('success_value'); 
  else 
    reject('error_value'); 
}); 

const promise2 = promise1.then((result) => { 
  console.log("promise1 resolve: " + result); 
}).catch((error) => { 
  console.log("promise1 reject: " + error); 
}); 

const promises = [promise1, promise2];
Promise.any(promises).then((value) => {
  console.log("Promise.any resolved with: " + value);
}).catch((error) => {
  console.log("Promise.any rejected with: " + error);
});
```

2.3 취약점 악용 (Exploitation of the Vulnerability)
공격자는 Promise.any() 함수를 이용해 메모리 누수를 유발하고, 이를 통해 JavaScript 객체의 주소를 획득한다. 이 정보는 이후 JIT 컴파일러 공격에서 중요한 역할을 한다. TheHole 값을 포함한 배열 요소를 조작하여 공격자는 내부 메모리 상태를 노출시킬 수 있다.

3. JIT Compiler Exploitation
3.1 개요 (Overview)
JIT 컴파일러는 JavaScript 코드를 실행 가능한 기계어로 변환하는 과정에서 성능 최적화를 수행한다. 그러나 이 과정에서 특정 취약점이 발생할 수 있다. 이번 섹션에서는 JIT 컴파일러의 최적화 과정에서 발생하는 취약점을 악용하는 방법을 설명한다.

3.2 취약점 분석 (Analysis of the Vulnerability)
JIT 컴파일러의 특정 최적화 패스에서 발생하는 메모리 취약점을 분석한다. 특히, 최적화 과정에서 배열 인덱스 검사를 생략하는 경우가 발생하며, 이를 통해 메모리의 임의 위치를 읽거나 쓸 수 있는 취약점이 생긴다.

배열 인덱스 검사 생략
JIT 컴파일러는 성능 최적화를 위해 배열 인덱스 검사를 생략할 수 있다. 예를 들어, 반복문에서 배열의 범위를 벗어난 인덱스에 접근하려 할 때, 일반적으로는 인덱스 범위 검사가 필요하다. 그러나 JIT 컴파일러는 이러한 검사를 생략함으로써 성능을 향상시키려 한다.

메모리 접근 예제
다음은 배열 인덱스 검사를 생략하는 과정에서 발생할 수 있는 메모리 접근 취약점의 예이다:

```
function triggerJITOptimization(arr) {
  for (let i = 0; i < 10000; i++) {
    arr[i % arr.length] = 1.1;
  }
  arr[0] = {}; // Create type confusion
  arr[1] = 2.3023e-320; // Trigger the vulnerability
}

let arr = [1.1, 1.2, 1.3];
triggerJITOptimization(arr);
```

이 코드는 반복문을 통해 JIT 컴파일러 최적화를 유도하고, 배열의 첫 번째 요소에 객체를 삽입하여 타입 혼동을 일으킨다. 이후 두 번째 요소에 매우 작은 값을 할당하여 취약점을 유발한다.

3.3 취약점 악용 (Exploitation of the Vulnerability)
공격자는 JIT 컴파일러의 최적화 과정에서 발생하는 취약점을 이용해 임의 코드 실행을 시도한다. 이를 위해 공격자는 먼저 JavaScript 코드를 통해 특정 메모리 패턴을 유도하고, 이후 최적화된 코드 실행을 통해 악성 코드를 실행한다.

```
function exploit(arr, rwx_page) {
  // 조작된 배열을 통해 메모리 쓰기
  arr[1] = {}; // Create type confusion
  arr[2] = 1.1;
  arr[3] = rwx_page; // RWX 메모리 페이지에 쓰기
}

let arr = [1.1, 1.2, 1.3];
let rwx_page = allocateRWXPage();
exploit(arr, rwx_page);
```

이 코드는 JIT 최적화 취약점을 통해 메모리에 악성 코드를 작성하고, RWX 페이지에 쓰기를 시도하여 임의 코드 실행을 달성한다.

4. 취약점 결합 (Combining the Exploits)

4.1 개요 (Overview)
앞서 설명한 두 가지 취약점을 결합하여 종합적인 공격 시나리오를 구축한다. 이를 통해 보다 강력하고 효과적인 원격 코드 실행 공격을 수행할 수 있다.

4.2 단계별 공격 시나리오 (Step-by-Step Attack Scenario)
Promise.any() 누수를 이용한 메모리 주소 획득: Promise.any() 함수를 이용해 메모리 누수를 유발하고, 이를 통해 JavaScript 객체의 주소를 획득한다.
JIT 컴파일러 취약점을 이용한 코드 실행: 획득한 메모리 주소를 기반으로 JIT 컴파일러의 취약점을 이용해 임의 코드를 실행한다.

4.3 방어 기법 (Defense Mechanisms)
이러한 공격을 방어하기 위해 가능한 다양한 방어 기법을 제안한다. 예를 들어, JIT 컴파일러의 최적화 과정에서 추가적인 검사를 도입하거나, Promise.any() 함수의 배열 관리를 강화하는 방법 등이 있다.

5. 결론 (Conclusion)

5.1 요약 (Summary)
이번 논문에서는 V8 엔진의 두 가지 주요 취약점을 분석하고, 이를 결합하여 원격 코드 실행 공격을 수행하는 방법을 설명했다. 이러한 분석을 통해 JavaScript 엔진의 보안 강화를 위한 방향성을 제시했다.

5.2 향후 연구 방향 (Future Research Directions)
향후 연구는 더 정교한 방어 기법을 개발하고, JavaScript 엔진의 보안을 강화하는 방향으로 진행될 예정이다.
